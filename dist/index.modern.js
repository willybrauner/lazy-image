const t={w:"width",x:"density"},e=t=>t.reduce((t,e)=>(t.width||0)>e.width?t:e,t[0]),n={LAZY_LOAD:"lazyload",LAZY_LOADING:"lazyloading",LAZY_LOADED:"lazyloaded"};function r({$root:r=document.body,$element:l,srcset:a,additonalUrl:s,lazyCallback:o=(()=>{}),observerOptions:i={},bigQuality:c=!1}={}){const u="data-background-srcset",d="data-background-id";let g;const b=[];let w=0;const m=()=>{A(),window.addEventListener("resize",O)},v=()=>{h(),m()},h=()=>{g.disconnect(),window.removeEventListener("resize",O)},O=()=>{v()},A=()=>{if(!("IntersectionObserver"in window))return;g=new IntersectionObserver(f,i);const t=l||a?l?[l]:null:(()=>{const t=r.querySelectorAll(`[${u}]:not(img):not(figure)`);return null!=t&&t.length?[...t]:null})();null==t||t.forEach(t=>{const e=y(t),n=null==b?void 0:b[t.getAttribute(d)];(!n||(null==n?void 0:n.width)<e.width&&e.width<=e.biggestImageDataOject.width)&&g.observe(t)})},f=t=>{null==t||t.forEach(async t=>{var e;const r=t.target;if(p(r,n.LAZY_LOAD),!t.isIntersecting)return;const l=y(r),a=r.getAttribute(d);a?b[a]=null==l?void 0:l.imageDataObject:(r.setAttribute(d,`${w}`),b[w]=null==l?void 0:l.imageDataObject,w++),null!=l&&null!=(e=l.imageDataObject)&&e.url&&(p(r,n.LAZY_LOADING),await D(r,l.imageDataObject.url),p(r,n.LAZY_LOADED),L(r,l.imageDataObject),g.unobserve(r))})},y=n=>{var r;const l=(null==(r=n.getBoundingClientRect())?void 0:r.width)||window.innerWidth,s=a||n.getAttribute(u),o=function(e){return((t,e)=>{let n=null,r=[];for(;null!==(n=e.exec(t));)r.push(n);return r})(e,/(\S*[^,\s])(\s+([\d.]+)(x|w))?/g).map(([,e,,n,r])=>{let l=t[r];return l?{url:e,[l]:parseFloat(n)}:{url:e}})}(s);return{width:l,dataSrcset:s,imageDataObject:function(t,n,r=!1){if(!t)return;const l=t.map(t=>null==t?void 0:t.width).sort((t,e)=>t-e).filter(t=>t>n),a=e(t),s=t.map(t=>t.width===l[r&&l.length>1?1:0]?t:a.width<=n?a:void 0).filter(t=>t);return s.length>0?s[0]:null}(o,l,c),biggestImageDataOject:e(o)}},L=(t,e)=>{t.style.backgroundImage=[`url('${e.url}')`,s&&`, url('${s}')`].filter(t=>t).join("")},D=(t,e)=>new Promise(t=>{const n=document.createElement("img");n.src=e,n.onload=()=>{t()}}),p=(t,e)=>{Object.values(n).forEach(e=>{t.classList.remove(e)}),t.classList.add(e),o(e)};return{start:m,update:v,stop:h}}function l({$element:t,srcset:e,src:r,$root:l=document.body,lazyCallback:a=(()=>{}),observerOptions:s={}}={}){let o;const i=!!t||!!r||!!e,c=()=>{d()},u=()=>{o.disconnect()},d=()=>{if(!("IntersectionObserver"in window))return;o=new IntersectionObserver(g,s);const e=i?t?[t]:null:(()=>{const t=[...l.querySelectorAll("[data-srcset]")||[],...l.querySelectorAll("[data-src]")||[]];return null!=t&&t.length?t:null})();null==e||e.forEach(t=>o.observe(t))},g=t=>{t.forEach(async t=>{const e=t.target;w(e,"lazyload"),t.isIntersecting&&(o.unobserve(e),w(e,"lazyloading"),await b(e),w(e,"lazyloaded"))})},b=t=>new Promise(n=>{const l=r||t.getAttribute("data-src"),a=e||t.getAttribute("data-srcset"),s=document.createElement("img");l&&(s.src=l),a&&(s.srcset=a),s.onload=()=>{l&&(t.src=l),a&&(t.srcset=a),n()}}),w=(t,e)=>{Object.values(n).forEach(e=>{t.classList.remove(e)}),t.classList.add(e),a(e)};return{start:c,update:()=>{u(),c()},stop:u}}export{r as lazyBackgroundImage,l as lazyImage,n as lazyState};
//# sourceMappingURL=index.modern.js.map
