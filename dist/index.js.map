{"version":3,"file":"index.js","sources":["../src/helpers.ts","../src/common.ts","../src/lazyBackgroundImage.ts","../src/lazyImage.ts"],"sourcesContent":["const descriptorNames = { w: \"width\", x: \"density\" } as const;\n\ntype TDescriptor = keyof typeof descriptorNames;\nexport type TDescriptorName = typeof descriptorNames[TDescriptor];\n\n// an srcset definition consists of responsive background image\nexport type TResponsiveBackgroundImage = { url: string } & {\n  [K in TDescriptorName]?: number;\n};\n\n/**\n * Parses an srcset string and returns an array of objects\n * @param {string} srcset\n */\nexport function parseSrcsetToArray(\n  srcset: string\n): TResponsiveBackgroundImage[] {\n  // a regex for matching srcset segments\n  const SRCSEG = /(\\S*[^,\\s])(\\s+([\\d.]+)(x|w))?/g;\n\n  const matchAll = (str: string, regex: RegExp): RegExpExecArray[] => {\n    let match = null,\n      result = [];\n    while ((match = regex.exec(str)) !== null) result.push(match);\n    return result;\n  };\n\n  return matchAll(srcset, SRCSEG).map(\n    ([, url, , value, modifier]): TResponsiveBackgroundImage => {\n      let modKey = descriptorNames[modifier];\n      // descriptor is optional\n      return modKey ? { url, [modKey]: parseFloat(value) } : { url };\n    }\n  );\n}\n\n/**\n * Get Biggest image object from data list\n * ex:\n *  [\n *    { url: \"/url\", width: 200 },\n *    { url: \"/url\", width: 500 },\n *    { url: \"/url\", width: 700 },\n *  ]\n *\n *  returns  { url: \"/url\", width: 700 }\n *\n * @param images\n */\nexport const getBiggestImageDataOject = (\n  images: TResponsiveBackgroundImage[]\n) =>\n  images.reduce(\n    (a: any, b: any) => ((a.width || 0) > b.width ? a : b),\n    images[0]\n  );\n\n/**\n * getImageDataObject\n *\n * @desc select appropriate data image\n *\n *  * ex:\n *  [\n *    { url: \"/url\", width: 200 },\n *    { url: \"/url\", width: 500 },\n *    { url: \"/url\", width: 700 },\n *  ]\n *\n *  if window width = 300\n *  returns  { url: \"/url\", width: 500 }\n *\n * @param images: images array\n * @param width: Width reference\n * @param bigQuality: if true, allow to selected the second biggest image (when possible) up to the width container reference\n */\nexport function getImageDataObject(\n  images: TResponsiveBackgroundImage[],\n  width: number,\n  bigQuality: boolean = false\n): TResponsiveBackgroundImage {\n  // check and exit if no images\n  if (!images) return;\n  // return available image width in array, depend of pWidth\n  const imagesWidth =\n    // get each el width\n    images\n      .map((el: TResponsiveBackgroundImage) => el?.width)\n      // sort smaller to larger\n      .sort((a: number, b: number) => a - b)\n      // return only images who got biggest width than pWidth\n      .filter((el: any) => el > width);\n\n  // keep the biggest image object of array\n  const biggestImage = getBiggestImageDataOject(images);\n\n  // prepare filtered image array we gonna return\n  const filtered = images\n    .map((el: any) => {\n      // if image width is smallest than the images array\n      // return it\n      if (\n        el.width === imagesWidth[bigQuality && imagesWidth.length > 1 ? 1 : 0]\n      )\n        return el;\n      // if the biggest image is smallest than the smallest image of array,\n      // return this biggest image\n      if (biggestImage.width <= width) return biggestImage;\n    })\n    // filter the array\n    .filter((val: any) => val);\n  // return the appropriate image object\n  return filtered.length > 0 ? filtered[0] : null;\n}\n","import { TLazy } from \"./types\";\n\nexport const lazyState: { [x: string]: TLazy } = {\n  LAZY_LOAD: \"lazyload\",\n  LAZY_LOADING: \"lazyloading\",\n  LAZY_LOADED: \"lazyloaded\",\n};\n","import {\n  getBiggestImageDataOject,\n  getImageDataObject,\n  parseSrcsetToArray,\n  TResponsiveBackgroundImage,\n} from \"./helpers\";\nimport { TLazy } from \"./types\";\nimport { lazyState } from \"./common\";\n\nexport type TLazyBackgroundImage = {\n  stop: () => void;\n  start: () => void;\n  update: () => void;\n};\n\n/**\n * @name lazyBackgroundImage\n * @desc Choose the appropriate image URL from srcset attr and\n * preload image before add its url in background-image style attr.\n *\n * @example1 with multiple elements\n *\n * - Add \"data-background-srcset\" attr on div:\n *    <div data-background-srcset=\"image-1.jpg 640w, image-2.jpg 1240w\" />\n *\n *    const bg = lazyBackgroundImage();\n *\n * - start\n *    bg.start();\n *\n * - update if new backgroundImage div with attr is inject in DOM\n *    bg.update();\n *\n * - stop to track and listen backgroundImage\n *    bg.stop();\n *\n *\n * @example2 with specific element\n *\n *  * - Add div:\n *    <div class=\"my-bg-img\" />\n *\n *     const bg = lazyBackgroundImage({\n *       $element: document.querySelector('.my-bg-img')\n *       srcset: \"image-1.jpg 640w, image-2.jpg 1240w\"\n *     });\n *\n *  * - start\n *    bg.start();\n *\n *    ...\n *\n */\n\nexport function lazyBackgroundImage({\n  $root = document.body,\n  $element,\n  srcset,\n  additonalUrl,\n  lazyCallback = () => {},\n  observerOptions = {},\n  bigQuality = false,\n}: {\n  $root?: HTMLElement;\n  $element?: HTMLElement;\n  srcset?: string;\n  additonalUrl?: string;\n  lazyCallback?: (state) => void;\n  observerOptions?: IntersectionObserverInit;\n  bigQuality?: boolean;\n} = {}): TLazyBackgroundImage {\n  const dataSrcsetAttr = \"data-background-srcset\";\n  const dataIdAttr = \"data-background-id\";\n  let observer: IntersectionObserver;\n  const storeImageList = [];\n  let ID = 0;\n\n  /**\n   * Start\n   */\n  const start = (): void => {\n    _observe();\n    window.addEventListener(\"resize\", _handlResize);\n  };\n\n  /**\n   * Update\n   */\n  const update = (): void => {\n    stop();\n    start();\n  };\n\n  /**\n   * Stop\n   */\n  const stop = (): void => {\n    observer.disconnect();\n    window.removeEventListener(\"resize\", _handlResize);\n  };\n\n  /**\n   * handle resize\n   */\n  const _handlResize = (): void => {\n    update();\n  };\n\n  /**\n   * Get elements with data-background-srcset attr\n   */\n  const _getElementsWithDataAttr = (): HTMLElement[] => {\n    const $els = $root.querySelectorAll(\n      `[${dataSrcsetAttr}]:not(img):not(figure)`\n    );\n    // @ts-ignore\n    return $els?.length ? [...$els] : null;\n  };\n\n  /**\n   * Start observer via intersection observer\n   */\n  const _observe = (): void => {\n    if (!(\"IntersectionObserver\" in window)) return;\n    observer = new IntersectionObserver(\n      _observeOnChangeCallBack,\n      observerOptions\n    );\n\n    // select dom element to observe\n    // depend of witch kind of element\n    // prettier-ignore\n    const elsToObserve = ($element || srcset)\n        ? $element ? [$element] : null\n        : _getElementsWithDataAttr();\n\n    elsToObserve?.forEach((el: HTMLElement) => {\n      // get current image informations\n      const imageInfos = _getImageInformations(el);\n      // get store image object\n      const storeImageObject = storeImageList?.[el.getAttribute(dataIdAttr)];\n\n      if (\n        // if store image doest exist\n        !storeImageObject ||\n        // or store image with is smaller than current image (dom) width\n        // and image (dom) width is smaller than the biggest width available\n        (storeImageObject?.width < imageInfos.width &&\n          imageInfos.width <= imageInfos.biggestImageDataOject.width)\n      ) {\n        observer.observe(el);\n      }\n    });\n  };\n\n  /**\n   * observer callback\n   * @param entries\n   */\n  const _observeOnChangeCallBack = (\n    entries: IntersectionObserverEntry[]\n  ): void => {\n    entries?.forEach(async (el) => {\n      const $current = el.target as HTMLElement;\n      // switch lazy callback\n      _switchLazyState($current, lazyState.LAZY_LOAD);\n\n      if (!el.isIntersecting) return;\n\n      // get current image information\n      const image = _getImageInformations($current);\n\n      // get data id on DOM element\n      const dataId = $current.getAttribute(dataIdAttr);\n\n      // if didn't exist, set in on DOM element and store it\n      if (!dataId) {\n        $current.setAttribute(dataIdAttr, `${ID}`);\n        storeImageList[ID] = image?.imageDataObject;\n        ID++;\n        // else, store it only\n      } else {\n        storeImageList[dataId] = image?.imageDataObject;\n      }\n\n      // check if data object url exist\n      if (!image?.imageDataObject?.url) return;\n\n      // switch lazy state\n      _switchLazyState($current, lazyState.LAZY_LOADING);\n      // start preload and wait\n      await _preloadImage($current, image.imageDataObject.url);\n      // switch lazy state\n      _switchLazyState($current, lazyState.LAZY_LOADED);\n      // then replace url\n      _replaceBackgroundImageUrl($current, image.imageDataObject);\n      // disconnect\n      observer.unobserve($current);\n    });\n  };\n\n  /**\n   * Get selected image information\n   * @param $el\n   */\n  const _getImageInformations = (\n    $el: HTMLElement\n  ): {\n    width: number;\n    dataSrcset: string;\n    imageDataObject: TResponsiveBackgroundImage;\n    biggestImageDataOject: TResponsiveBackgroundImage;\n  } => {\n    // get image width reference\n    const width = $el.getBoundingClientRect()?.width || window.innerWidth;\n    // get image URL\n    const dataSrcset = srcset || $el.getAttribute(dataSrcsetAttr);\n    // extract image array from from srcset\n    const imagesArray = parseSrcsetToArray(dataSrcset);\n    // get image object depend of current width and quality size\n    const imageDataObject = getImageDataObject(imagesArray, width, bigQuality);\n    // ge biggest image object from image data array\n    const biggestImageDataOject = getBiggestImageDataOject(imagesArray);\n\n    return {\n      width,\n      dataSrcset,\n      imageDataObject,\n      biggestImageDataOject,\n    };\n  };\n\n  /**\n   * Replace background image URL depend of element size\n   * @param $element\n   * @param imageDataObject\n   */\n  const _replaceBackgroundImageUrl = (\n    $element: HTMLElement,\n    imageDataObject: TResponsiveBackgroundImage\n  ): void => {\n    $element.style.backgroundImage = [\n      `url('${imageDataObject.url}')`,\n      additonalUrl && `, url('${additonalUrl}')`,\n    ]\n      .filter((v) => v)\n      .join(\"\");\n  };\n\n  /**\n   * Preload image url\n   * Set lazy class\n   * @param $el\n   * @param url\n   */\n  const _preloadImage = ($el: HTMLElement, url: string): Promise<void> =>\n    new Promise((resolve) => {\n      // create void image tag for each url\n      const $img = document.createElement(\"img\");\n      // add url to src attr in order to start loading\n      $img.src = url;\n      $img.onload = () => {\n        resolve();\n      };\n    });\n\n  /**\n   * Switch lazyState and execute lazyCallback\n   * @param $el\n   * @param state\n   */\n  const _switchLazyState = ($el, state: TLazy): void => {\n    // remove all lazy class\n    Object.values(lazyState).forEach((el) => {\n      $el.classList.remove(el);\n    });\n    // add param lazyclass\n    $el.classList.add(state);\n    // execute callback\n    lazyCallback(state);\n  };\n\n  return {\n    start,\n    update,\n    stop,\n  };\n}\n","import { TLazy } from \"./types\";\nimport { lazyState } from \"./common\";\n\ntype TLazyImageParams = {\n  $element?: HTMLElement;\n  src?: string;\n  srcset?: string;\n  $root?: HTMLElement;\n  lazyCallback?: (state) => void;\n  observerOptions?: IntersectionObserverInit;\n};\n\nexport type TLazyImage = {\n  stop: () => void;\n  start: () => void;\n  update: () => void;\n};\n\n/**\n * @name lazyImage\n * @desc Choose the appropriate image URL from srcset attr and\n * preload image before add its url in background-image style attr.\n *\n */\nexport function lazyImage({\n  $element,\n  srcset,\n  src,\n  $root = document.body,\n  lazyCallback = () => {},\n  observerOptions = {},\n}: TLazyImageParams = {}): TLazyImage {\n  const dataSrcsetAttr = \"data-srcset\";\n  const dataSrcAttr = \"data-src\";\n  let observer: IntersectionObserver;\n\n  // check props to know if specific src\n  const isSpecificElement = !!$element || !!src || !!srcset;\n\n  /**\n   * Start\n   */\n  const start = (): void => {\n    _observe();\n  };\n\n  /**\n   * Update\n   */\n  const update = (): void => {\n    stop();\n    start();\n  };\n\n  /**\n   * Stop\n   */\n  const stop = (): void => {\n    observer.disconnect();\n  };\n\n  /**\n   * Get elements with data-src or data-srcset attr\n   */\n  // prettier-ignore\n  const _getElementsWithDataAttr = (): HTMLImageElement[] => {\n     const $els = [\n        // @ts-ignore\n        ...($root.querySelectorAll(`[${dataSrcsetAttr}]`) || []),\n        ...($root.querySelectorAll(`[${dataSrcAttr}]`) || []),\n      ];\n      return $els?.length ? $els : null;\n    };\n\n  /**\n   * Start observer via intersection observer\n   */\n  const _observe = (): void => {\n    if (!(\"IntersectionObserver\" in window)) return;\n    observer = new IntersectionObserver(\n      _observeOnChangeCallBack,\n      observerOptions\n    );\n    // get elements to observe\n    // prettier-ignore\n    const elsToObserve = isSpecificElement\n      ? $element ? [$element] : null : _getElementsWithDataAttr();\n\n    elsToObserve?.forEach((el) => observer.observe(el));\n  };\n\n  /**\n   *\n   * @param entries\n   */\n  const _observeOnChangeCallBack = (\n    entries: IntersectionObserverEntry[]\n  ): void => {\n    entries.forEach(async (el) => {\n      const $current = el.target as HTMLImageElement;\n      // switch lazyState\n      _switchLazyState($current, \"lazyload\");\n      if (el.isIntersecting) {\n        // disconnect\n        observer.unobserve($current);\n        // switch lazyState\n        _switchLazyState($current, \"lazyloading\");\n        // start preload and replace\n        await _preloadImage($current);\n        // switch lazyState\n        _switchLazyState($current, \"lazyloaded\");\n      }\n    });\n  };\n\n  /**\n   * Preload images and set new URL in src or srcset attr\n   * @param $el\n   */\n  const _preloadImage = ($el: HTMLImageElement): Promise<void> => {\n    return new Promise((resolve) => {\n      const dataSrcValue = src || $el.getAttribute(dataSrcAttr);\n      const dataSrcSetValue = srcset || $el.getAttribute(dataSrcsetAttr);\n\n      // create void image tag for start preload\n      const $fakeImg = document.createElement(\"img\");\n      if (dataSrcValue) $fakeImg.src = dataSrcValue;\n      if (dataSrcSetValue) $fakeImg.srcset = dataSrcSetValue;\n\n      $fakeImg.onload = () => {\n        if (dataSrcValue) $el.src = dataSrcValue;\n        if (dataSrcSetValue) $el.srcset = dataSrcSetValue;\n        resolve();\n      };\n    });\n  };\n\n  /**\n   * Switch lazyState and execute lazyCallback\n   * @param $el\n   * @param state\n   */\n  const _switchLazyState = ($el, state: TLazy): void => {\n    // remove all lazy class\n    Object.values(lazyState).forEach((el) => {\n      $el.classList.remove(el);\n    });\n    // add param lazyclass\n    $el.classList.add(state);\n    // execute callback\n    lazyCallback(state);\n  };\n\n  return {\n    start,\n    update,\n    stop,\n  };\n}\n"],"names":["descriptorNames","w","x","getBiggestImageDataOject","images","reduce","a","b","width","lazyState","LAZY_LOAD","LAZY_LOADING","LAZY_LOADED","$root","document","body","$element","srcset","additonalUrl","lazyCallback","observerOptions","bigQuality","dataSrcsetAttr","dataIdAttr","observer","storeImageList","ID","start","_observe","window","addEventListener","_handlResize","update","stop","disconnect","removeEventListener","IntersectionObserver","_observeOnChangeCallBack","elsToObserve","$els","querySelectorAll","length","_getElementsWithDataAttr","forEach","el","imageInfos","_getImageInformations","storeImageObject","getAttribute","biggestImageDataOject","observe","entries","$current","target","_switchLazyState","isIntersecting","image","dataId","imageDataObject","setAttribute","_image$imageDataObjec","url","_preloadImage","_replaceBackgroundImageUrl","unobserve","$el","getBoundingClientRect","innerWidth","dataSrcset","imagesArray","str","regex","match","result","exec","push","matchAll","map","value","modifier","modKey","parseFloat","parseSrcsetToArray","imagesWidth","sort","filter","biggestImage","filtered","val","getImageDataObject","style","backgroundImage","v","join","Promise","resolve","$img","createElement","src","onload","state","Object","values","classList","remove","add","isSpecificElement","dataSrcValue","dataSrcSetValue","$fakeImg"],"mappings":"AAAA,MAAMA,EAAkB,CAAEC,EAAG,QAASC,EAAG,WAiD5BC,EACXC,GAEAA,EAAOC,OACL,CAACC,EAAQC,KAAaD,EAAEE,OAAS,GAAKD,EAAEC,MAAQF,EAAIC,EACpDH,EAAO,ICpDEK,EAAoC,CAC/CC,UAAW,WACXC,aAAc,cACdC,YAAa,oDCiDqBC,MAClCA,EAAQC,SAASC,KADiBC,SAElCA,EAFkCC,OAGlCA,EAHkCC,aAIlCA,EAJkCC,aAKlCA,EAAe,SALmBC,gBAMlCA,EAAkB,GANgBC,WAOlCA,GAAa,GASX,IACF,MAAMC,EAAiB,yBACjBC,EAAa,qBACnB,IAAIC,EACJ,MAAMC,EAAiB,GACvB,IAAIC,EAAK,EAKT,MAAMC,EAAQ,KACZC,IACAC,OAAOC,iBAAiB,SAAUC,IAM9BC,EAAS,KACbC,IACAN,KAMIM,EAAO,KACXT,EAASU,aACTL,OAAOM,oBAAoB,SAAUJ,IAMjCA,EAAe,KACnBC,KAiBIJ,EAAW,KACf,KAAM,yBAA0BC,QAAS,OACzCL,EAAW,IAAIY,qBACbC,EACAjB,GAMF,MAAMkB,EAAgBtB,GAAYC,EAC5BD,EAAW,CAACA,GAAY,KAtBC,MAC/B,MAAMuB,EAAO1B,EAAM2B,qBACblB,2BAGN,aAAOiB,GAAAA,EAAME,OAAS,IAAIF,GAAQ,MAkB5BG,SAENJ,GAAAA,EAAcK,QAASC,IAErB,MAAMC,EAAaC,EAAsBF,GAEnCG,QAAmBtB,SAAAA,EAAiBmB,EAAGI,aAAazB,MAIvDwB,UAGAA,SAAAA,EAAkBvC,OAAQqC,EAAWrC,OACpCqC,EAAWrC,OAASqC,EAAWI,sBAAsBzC,QAEvDgB,EAAS0B,QAAQN,MASjBP,EACJc,UAEAA,GAAAA,EAASR,iBAAeC,aACtB,MAAMQ,EAAWR,EAAGS,OAIpB,GAFAC,EAAiBF,EAAU3C,EAAUC,YAEhCkC,EAAGW,eAAgB,yBAGxB,MAAMC,EAAQV,EAAsBM,GAG9BK,EAASL,EAASJ,aAAazB,GAarC,OAVKkC,EAMHhC,EAAegC,SAAUD,SAAAA,EAAOE,iBALhCN,EAASO,aAAapC,KAAeG,KACrCD,EAAeC,SAAM8B,SAAAA,EAAOE,gBAC5BhC,WAOG8B,YAAAA,EAAOE,kBAAPE,EAAwBC,KAG7BP,EAAiBF,EAAU3C,EAAUE,8BAE/BmD,EAAcV,EAAUI,EAAME,gBAAgBG,sBAEpDP,EAAiBF,EAAU3C,EAAUG,aAErCmD,EAA2BX,EAAUI,EAAME,iBAE3ClC,EAASwC,UAAUZ,wBAnCrB,sCA2CIN,EACJmB,UAQA,MAAMzD,YAAQyD,EAAIC,kCAAyB1D,QAASqB,OAAOsC,WAErDC,EAAanD,GAAUgD,EAAIjB,aAAa1B,GAExC+C,WF3MRpD,GAYA,MAPiB,EAACqD,EAAaC,KAC7B,IAAIC,EAAQ,KACVC,EAAS,GACX,KAAqC,QAA7BD,EAAQD,EAAMG,KAAKJ,KAAgBG,EAAOE,KAAKH,GACvD,OAAOC,GAGFG,CAAS3D,EATD,mCASiB4D,IAC9B,GAAIhB,GAAOiB,EAAOC,MAChB,IAAIC,EAAShF,EAAgB+E,GAE7B,OAAOC,EAAS,CAAEnB,IAAAA,EAAKmB,CAACA,GAASC,WAAWH,IAAW,CAAEjB,IAAAA,KE2LvCqB,CAAmBd,GAMvC,MAAO,CACL5D,MAAAA,EACA4D,WAAAA,EACAV,yBFtJJtD,EACAI,EACAa,GAAsB,GAGtB,IAAKjB,EAAQ,OAEb,MAAM+E,EAEJ/E,EACGyE,IAAKjC,SAAmCA,SAAAA,EAAIpC,OAE5C4E,KAAK,CAAC9E,EAAWC,IAAcD,EAAIC,GAEnC8E,OAAQzC,GAAYA,EAAKpC,GAGxB8E,EAAenF,EAAyBC,GAGxCmF,EAAWnF,EACdyE,IAAKjC,GAIFA,EAAGpC,QAAU2E,EAAY9D,GAAc8D,EAAY1C,OAAS,EAAI,EAAI,GAE7DG,EAGL0C,EAAa9E,OAASA,EAAc8E,OAAxC,GAGDD,OAAQG,GAAaA,GAExB,OAAOD,EAAS9C,OAAS,EAAI8C,EAAS,GAAK,KE4GjBE,CAAmBpB,EAAa7D,EAAOa,GAQ7D4B,sBAN4B9C,EAAyBkE,KAenDN,EAA6B,CACjC/C,EACA0C,KAEA1C,EAAS0E,MAAMC,gBAAkB,SACvBjC,EAAgBG,QACxB3C,aAA0BA,OAEzBmE,OAAQO,GAAMA,GACdC,KAAK,KASJ/B,EAAgB,CAACG,EAAkBJ,IACvC,IAAIiC,QAASC,IAEX,MAAMC,EAAOlF,SAASmF,cAAc,OAEpCD,EAAKE,IAAMrC,EACXmC,EAAKG,OAAS,KACZJ,OASAzC,EAAmB,CAACW,EAAKmC,KAE7BC,OAAOC,OAAO7F,GAAWkC,QAASC,IAChCqB,EAAIsC,UAAUC,OAAO5D,KAGvBqB,EAAIsC,UAAUE,IAAIL,GAElBjF,EAAaiF,IAGf,MAAO,CACLzE,MAAAA,EACAK,OAAAA,EACAC,KAAAA,gCCrQsBjB,SACxBA,EADwBC,OAExBA,EAFwBiF,IAGxBA,EAHwBrF,MAIxBA,EAAQC,SAASC,KAJOI,aAKxBA,EAAe,SALSC,gBAMxBA,EAAkB,IACE,IAGpB,IAAII,EAGJ,MAAMkF,IAAsB1F,KAAckF,KAASjF,EAK7CU,EAAQ,KACZC,KAcIK,EAAO,KACXT,EAASU,cAmBLN,EAAW,KACf,KAAM,yBAA0BC,QAAS,OACzCL,EAAW,IAAIY,qBACbC,EACAjB,GAIF,MAAMkB,EAAeoE,EACjB1F,EAAW,CAACA,GAAY,KArBG,MAC9B,MAAMuB,EAAO,IAEN1B,EAAM2B,mCAA2C,MACjD3B,EAAM2B,gCAAwC,IAEpD,aAAOD,GAAAA,EAAME,OAASF,EAAO,MAeIG,SAEnCJ,GAAAA,EAAcK,QAASC,GAAOpB,EAAS0B,QAAQN,KAO3CP,EACJc,IAEAA,EAAQR,iBAAeC,OACrB,MAAMQ,EAAWR,EAAGS,OAEpBC,EAAiBF,EAAU,kCACvBR,EAAGW,sBAEL/B,EAASwC,UAAUZ,GAEnBE,EAAiBF,EAAU,+BAErBU,EAAcV,oBAEpBE,EAAiBF,EAAU,iFAZ/B,sCAqBIU,EAAiBG,OACV6B,QAASC,IAClB,MAAMY,EAAeT,GAAOjC,EAAIjB,aAxFhB,YAyFV4D,EAAkB3F,GAAUgD,EAAIjB,aA1FnB,eA6Fb6D,EAAW/F,SAASmF,cAAc,OACpCU,IAAcE,EAASX,IAAMS,GAC7BC,IAAiBC,EAAS5F,OAAS2F,GAEvCC,EAASV,OAAS,KACZQ,IAAc1C,EAAIiC,IAAMS,GACxBC,IAAiB3C,EAAIhD,OAAS2F,GAClCb,OAUAzC,EAAmB,CAACW,EAAKmC,KAE7BC,OAAOC,OAAO7F,GAAWkC,QAASC,IAChCqB,EAAIsC,UAAUC,OAAO5D,KAGvBqB,EAAIsC,UAAUE,IAAIL,GAElBjF,EAAaiF,IAGf,MAAO,CACLzE,MAAAA,EACAK,OA1Ga,KACbC,IACAN,KAyGAM,KAAAA"}