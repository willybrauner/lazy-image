const t={w:"width",x:"density"},e=t=>t.reduce((t,e)=>(t.width||0)>e.width?t:e,t[0]),r={LAZY_LOAD:"lazyload",LAZY_LOADING:"lazyloading",LAZY_LOADED:"lazyloaded"};function n({$root:n=document.body,$element:o,srcset:l,additonalUrl:s,lazyCallback:i=(()=>{}),observerOptions:a={},bigQuality:c=!1}={}){const u="data-background-srcset",d="data-background-id";let g;const m=[];let b=0;const v=()=>{O(),window.addEventListener("resize",f)},h=()=>{w(),v()},w=()=>{g.disconnect(),window.removeEventListener("resize",f)},f=()=>{h()},O=()=>{if(!("IntersectionObserver"in window))return;g=new IntersectionObserver(A,a);const t=o||l?o?[o]:null:(()=>{const t=n.querySelectorAll(`[${u}]:not(img):not(figure)`);return null!=t&&t.length?[...t]:null})();null==t||t.forEach(t=>{const e=y(t),r=null==m?void 0:m[t.getAttribute(d)];(!r||(null==r?void 0:r.width)<e.width&&e.width<=e.biggestImageDataOject.width)&&g.observe(t)})},A=t=>{null==t||t.forEach(function(t){try{var e;const n=t.target;if(j(n,r.LAZY_LOAD),!t.isIntersecting)return Promise.resolve();const o=y(n),l=n.getAttribute(d);return l?m[l]=null==o?void 0:o.imageDataObject:(n.setAttribute(d,`${b}`),m[b]=null==o?void 0:o.imageDataObject,b++),null!=o&&null!=(e=o.imageDataObject)&&e.url?(j(n,r.LAZY_LOADING),Promise.resolve(D(n,o.imageDataObject.url)).then(function(){j(n,r.LAZY_LOADED),L(n,o.imageDataObject),g.unobserve(n)})):Promise.resolve()}catch(t){return Promise.reject(t)}})},y=r=>{var n;const o=(null==(n=r.getBoundingClientRect())?void 0:n.width)||window.innerWidth,s=l||r.getAttribute(u),i=function(e){return((t,e)=>{let r=null,n=[];for(;null!==(r=e.exec(t));)n.push(r);return n})(e,/(\S*[^,\s])(\s+([\d.]+)(x|w))?/g).map(([,e,,r,n])=>{let o=t[n];return o?{url:e,[o]:parseFloat(r)}:{url:e}})}(s);return{width:o,dataSrcset:s,imageDataObject:function(t,r,n=!1){if(!t)return;const o=t.map(t=>null==t?void 0:t.width).sort((t,e)=>t-e).filter(t=>t>r),l=e(t),s=t.map(t=>t.width===o[n&&o.length>1?1:0]?t:l.width<=r?l:void 0).filter(t=>t);return s.length>0?s[0]:null}(i,o,c),biggestImageDataOject:e(i)}},L=(t,e)=>{t.style.backgroundImage=[`url('${e.url}')`,s&&`, url('${s}')`].filter(t=>t).join("")},D=(t,e)=>new Promise(t=>{const r=document.createElement("img");r.src=e,r.onload=()=>{t()}}),j=(t,e)=>{Object.values(r).forEach(e=>{t.classList.remove(e)}),t.classList.add(e),i(e)};return{start:v,update:h,stop:w}}function o({$element:t,srcset:e,src:n,$root:o=document.body,lazyCallback:l=(()=>{}),observerOptions:s={}}={}){let i;const a=!!t||!!n||!!e,c=()=>{d()},u=()=>{i.disconnect()},d=()=>{if(!("IntersectionObserver"in window))return;i=new IntersectionObserver(g,s);const e=a?t?[t]:null:(()=>{const t=[...o.querySelectorAll("[data-srcset]")||[],...o.querySelectorAll("[data-src]")||[]];return null!=t&&t.length?t:null})();null==e||e.forEach(t=>i.observe(t))},g=t=>{t.forEach(function(t){try{const e=t.target;b(e,"lazyload");const r=function(){if(t.isIntersecting)return i.unobserve(e),b(e,"lazyloading"),Promise.resolve(m(e)).then(function(){b(e,"lazyloaded")})}();return Promise.resolve(r&&r.then?r.then(function(){}):void 0)}catch(t){return Promise.reject(t)}})},m=t=>new Promise(r=>{const o=n||t.getAttribute("data-src"),l=e||t.getAttribute("data-srcset"),s=document.createElement("img");o&&(s.src=o),l&&(s.srcset=l),s.onload=()=>{o&&(t.src=o),l&&(t.srcset=l),r()}}),b=(t,e)=>{Object.values(r).forEach(e=>{t.classList.remove(e)}),t.classList.add(e),l(e)};return{start:c,update:()=>{u(),c()},stop:u}}export{n as lazyBackgroundImage,o as lazyImage,r as lazyState};
//# sourceMappingURL=index.module.js.map
